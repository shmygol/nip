## This module provides various [Matcher] functions,
## that can be used to assert that a given input is in a certain format,
## and [Match.all_specs],
## that matches a list of [Spec]s with [Matcher]s against a given input
## and returns a dictionary, used by [Nip.match_all].
module [
    Spec,
    Matcher,
    all_specs,
    anything,
    literal,
    negated_charset,
    charset,
    whitespace,
    word,
    signed_integer,
    unsigned_integer,
    decimal,
]

import Interval exposing [Interval]

# Matcher and Spec below need a type variable
# because tag unions in type aliases are closed by default
# see https://roc.zulipchat.com/#narrow/channel/231634-beginners/topic/Type.20mismatch.20with.20a.20function.20in.20arguments/near/512117920

## Type alias for a matcher function.
##
## Unfortunately, the type variable `a` is needed here
## because tag unions in type aliases are closed by default.
## See [the Zulip thread](https://roc.zulipchat.com/#narrow/channel/231634-beginners/topic/Type.20mismatch.20with.20a.20function.20in.20arguments/near/512117920)
Matcher a : List U8 -> Result (List U8) [DoesNotMatch]a

## A spec defines a field name, length and a matcher function.
## [Template.parse_template] parses a template string into a list of specs.
##
## Here the type variable `a` is needed as well.
## To use `Spec` in the arguments definition use `(Spec _)`.
## See [the Zulip thread](https://roc.zulipchat.com/#narrow/channel/231634-beginners/topic/Type.20mismatch.20with.20a.20function.20in.20arguments/near/512117920)
Spec a : {
    field_name : [Anonymous, Named Str],
    length : Interval Unsigned64,
    matcher : Matcher a,
}

## A matcher to match any input.
anything : Matcher _
anything = |input|
    Ok(input)

## Returns a matcher that matches a given literal.
literal : List U8 -> Matcher _
literal = |value|
    |input|
        if input == value then
            Ok(input)
        else
            Err(DoesNotMatch)

expect
    # that matcher generated by `literal`
    # returns `Ok` with the input
    # when the input matches the literal
    input = ['a', 'b']
    actual = literal(['a', 'b'])(input)
    actual == Ok(['a', 'b'])

expect
    # that matcher generated by `literal`
    # returns `Err(DoesNotMatch)`
    # when the input does not match the value
    input = ['n', 'o']
    actual = literal(['a', 'b'])(input)
    actual == Err(DoesNotMatch)

## Returns a matcher,
## that matches all input bytes except the ones in the given charset.
negated_charset : List U8 -> Matcher _
negated_charset = |disallowed_bytes|
    |input|
        if
            Set.intersection(
                Set.from_list(input),
                Set.from_list(disallowed_bytes),
            )
            == Set.empty({})
        then
            Ok(input)
        else
            Err(DoesNotMatch)

expect
    # that matcher generated by `negated_charset`
    # returns `Ok` with the input
    # when the input does not match the charset
    input = ['p', 'u', 'n', 'k']
    actual = negated_charset(['a', 'b'])(input)
    actual == Ok(input)

expect
    # that matcher generated by `negated_charset`
    # returns `Err(DoesNotMatch)`
    # when at least one of the disallowed bytes is present
    input = ['b', 'c', 'd']
    actual = negated_charset(['a', 'b'])(input)
    actual == Err(DoesNotMatch)

## Returns a matcher that matches a given charset.
charset : List U8 -> Matcher _
charset = |allowed_bytes|
    |input|
        if
            Set.difference(
                Set.from_list(input),
                Set.from_list(allowed_bytes),
            )
            == Set.empty({})
        then
            Ok(input)
        else
            Err(DoesNotMatch)

expect
    # that matcher generated by `charset`
    # returns `Ok` with the input
    # when the input matches the charset
    input = ['a', 'b', 'b', 'a']
    actual = charset(['a', 'b'])(input)
    actual == Ok(input)

expect
    # that matcher generated by `charset`
    # returns `Err(DoesNotMatch)`
    # when the input does not match the charset
    input = ['a', 'b', 'c']
    actual = charset(['a', 'b'])(input)
    actual == Err(DoesNotMatch)

expect
    # that matcher generated by `charset`
    # returns `Err(DoesNotMatch)`
    # when the input does not match case of the charset
    input = ['A', 'B', 'B', 'A']
    actual = charset(['a', 'b'])(input)
    actual == Err(DoesNotMatch)

## Alias for `charset([' ', '\t', '\n', '\r'])`
whitespace : Matcher _
whitespace = charset([' ', '\t', '\n', '\r'])

## Alias for `negated_charset([' ', '\t', '\n', '\r'])`
word : Matcher _
word = negated_charset([' ', '\t', '\n', '\r'])

## Internal helper function,
## that returns a matcher for numbers.
number : (Str -> Result (Num _) _) -> Matcher _
number = |to_num|
    |input|
        input
        |> Str.from_utf8_lossy
        |> to_num
        |> Result.map_err(|_| DoesNotMatch)?
        |> Num.to_str
        |> Str.to_utf8
        |> Ok

## A matcher to match a signed integer (I64).
signed_integer : Matcher _
signed_integer = number(Str.to_i64)

expect
    # that `signed_integer` returns `Ok` with the input
    # when the input is a valid integer
    input = ['1', '2', '3']
    actual = signed_integer(input)
    actual == Ok(['1', '2', '3'])

expect
    # that `signed_integer` returns `Ok` with the input
    # when the input is a negative integer
    input = ['-', '2', '3']
    actual = signed_integer(input)
    actual == Ok(['-', '2', '3'])

expect
    # that `signed_integer` returns `Err(DoesNotMatch)`
    # when the input is not a valid integer
    input = ['1', '2', 'c']
    actual = signed_integer(input)
    actual == Err(DoesNotMatch)

expect
    # that `signed_integer` returns `Err(DoesNotMatch)`
    # when the input is a decimal number
    input = ['1', '.', '3']
    actual = signed_integer(input)
    actual == Err(DoesNotMatch)

## A matcher to match a signed integer (I64).
unsigned_integer : Matcher _
unsigned_integer = number(Str.to_u64)

expect
    # that `unsigned_integer` returns `Ok` with the input
    # when the input is a valid integer
    input = ['1', '2', '3']
    actual = unsigned_integer(input)
    actual == Ok(['1', '2', '3'])

expect
    # that `unsigned_integer` returns `Err(DoesNotMatch)`
    # when the input is a negative integer
    input = ['-', '2', '3']
    actual = unsigned_integer(input)
    actual == Err(DoesNotMatch)

expect
    # that `unsigned_integer` returns `Err(DoesNotMatch)`
    # when the input is not a valid integer
    input = ['1', '2', 'c']
    actual = unsigned_integer(input)
    actual == Err(DoesNotMatch)

expect
    # that `unsigned_integer` returns `Err(DoesNotMatch)`
    # when the input is a decimal number
    input = ['1', '.', '3']
    actual = unsigned_integer(input)
    actual == Err(DoesNotMatch)

decimal : Matcher _
decimal = number(Str.to_dec)

expect
    # that `decimal` returns `Ok` with the input
    # when the input is a valid integer
    input = ['1', '2', '3']
    actual = decimal(input)
    actual == Ok(['1', '2', '3', '.', '0'])

expect
    # that `decimal` returns `Ok` with the input
    # when the input is a negative integer
    input = ['-', '2', '3']
    actual = decimal(input)
    actual == Ok(['-', '2', '3', '.', '0'])

expect
    # that `decimal` returns `Ok` with the input
    # when the input is a decimal number
    input = ['1', '.', '3']
    actual = decimal(input)
    actual == Ok(['1', '.', '3'])

expect
    # that `decimal` returns `Ok` with the input
    # when the input is a negative decimal number
    input = ['-', '1', '.', '3']
    actual = decimal(input)
    actual == Ok(['-', '1', '.', '3'])

expect
    # that `decimal` returns `Err(DoesNotMatch)`
    # when the input is not a valid integer
    input = ['1', '2', 'c']
    actual = decimal(input)
    actual == Err(DoesNotMatch)

## Interval helper function,
## that returns an error if the input bytes length is less than the requested minimum,
## otherwise returns the input bytes back.
assert_min_length : List U8, U64 -> Result (List U8) [DoesNotMatch]
assert_min_length = |bytes, min_length|
    if List.len(bytes) < min_length then
        Err(DoesNotMatch)
    else
        Ok(bytes)

## See `all_specs` for the public API.
## Warning: the function is not tail optimized,
## so it may cause a stack overflow for large inputs.
all_specs_recursive : List U8, List (Spec _), Dict Str Str -> Result (Dict Str Str) [DoesNotMatch]
all_specs_recursive = |input, specs, acc|
    when specs is
        [] ->
            if input == [] then
                Ok(acc)
            else
                Err(DoesNotMatch)

        [spec, .. as rest_specs] ->
            spec.length
            |> Interval.bounded_within(1, List.len(input))
            |> Result.map_err(|_| DoesNotMatch)?
            |> Interval.walk_until(
                Ok(acc),
                |_, length|
                    List.split_at(input, length)
                    |> |{ before: input_segment, others: rest_input }|
                        # Even though `field_value` is not always used,
                        # it's important to call `spec.matcher?` here
                        field_value =
                            input_segment
                            |> assert_min_length(length)?
                            |> spec.matcher?
                            |> Str.from_utf8_lossy

                        all_specs_recursive(
                            rest_input,
                            rest_specs,
                            when spec.field_name is
                                Named(name) -> Dict.insert(acc, name, field_value)
                                Anonymous -> acc,
                        )
                    |> |branch_result|
                        when branch_result is
                            Ok(fields) -> Break(Ok(fields))
                            Err(error) -> Continue(Err(error)),
            )

## Attempts to match a list of `Spec`s against the given input (as a list of bytes).
##
## Each `Spec` defines a field name, length and a matcher function.
## If all specs match successfully, returns a dictionary with named fields and their values,
## otherwise returns `Err(DoesNotMatch)`.
all_specs : List U8, List (Spec _) -> Result (Dict Str Str) [DoesNotMatch]
all_specs = |input, specs|
    all_specs_recursive(input, specs, Dict.empty({}))

expect
    # that `all_specs` passes segment of a request size
    # and returns `Ok` with the correct values
    # when input matches specs with defined length
    input = ['B', 'u', 'z', 'z', 'F', 'u', 'z', 'z']
    specs = [
        {
            field_name: Named("field1"),
            length: Interval.exact(4),
            matcher: literal(['B', 'u', 'z', 'z']),
        },
        {
            field_name: Named("field2"),
            length: Interval.exact(4),
            matcher: literal(['F', 'u', 'z', 'z']),
        },
    ]
    actual = all_specs(input, specs)
    actual == Ok(Dict.from_list([("field1", "Buzz"), ("field2", "Fuzz")]))

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when at least one of the matchers returns `Err(DoesNotMatch)
    input = ['*', '*']
    specs = [
        {
            field_name: Named("field1"),
            length: Interval.exact(1),
            matcher: |x| Ok(x),
        },
        {
            field_name: Named("field2"),
            length: Interval.exact(1),
            matcher: |_| Err(DoesNotMatch),
        },
    ]
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when the specs list is empty but the input is not
    input = ['*']
    specs = []
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)

expect
    # that `all_specs` returns `Ok` with an empty dictionary
    # when the specs list and the input are empty
    input = []
    specs = []
    actual = all_specs(input, specs)
    actual == Ok(Dict.empty({}))

expect
    # that `all_specs` returns `Ok` with an empty dictionary
    # when the specs list and the input are empty
    input = []
    specs = []
    actual = all_specs(input, specs)
    actual == Ok(Dict.empty({}))

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when the input is too short, e.g. 5 < 2 + 5
    input = ['1', '2', '3', '4', '5']
    specs = [
        {
            field_name: Named("field1"),
            length: Interval.exact(2),
            matcher: |x| Ok(x),
        },
        {
            field_name: Named("field2"),
            length: Interval.exact(5),
            matcher: |x| Ok(x),
        },
    ]
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)

expect
    # that `all_specs` returns `Ok` but without matching values
    # when the fields are anonymous
    input = ['*']
    specs = [
        {
            field_name: Anonymous,
            length: Interval.exact(1),
            matcher: |x| Ok(x),
        },
    ]
    actual = all_specs(input, specs)
    actual == Ok(Dict.empty({}))

expect
    # that `all_specs` passes segment of a request size
    # and returns `Ok` with the correct values
    # when input matches specs with undefined length
    input = ['B', 'u', 'z', 'z', 'F', 'u', 'z', 'z']
    specs = [
        {
            field_name: Named("field1"),
            length: Interval.all,
            matcher: anything,
        },
        {
            field_name: Named("field2"),
            length: Interval.exact(4),
            matcher: literal(['F', 'u', 'z', 'z']),
        },
    ]
    actual = all_specs(input, specs)
    actual == Ok(Dict.from_list([("field1", "Buzz"), ("field2", "Fuzz")]))

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when input doesn't match specs with undefined length
    input = ['B', 'u', 'z', 'z', 'F', 'u', 'z', 'z']
    specs = [
        {
            field_name: Named("field1"),
            length: Interval.all,
            matcher: literal(['B', 'u', 'z']),
        },
        {
            field_name: Named("field2"),
            length: Interval.exact(4),
            matcher: literal(['F', 'u', 'z', 'z']),
        },
    ]
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)
