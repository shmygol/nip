## This module provides various [Matcher] functions,
## that can be used to assert that a given input is in a certain format,
## and [Match.all_specs],
## that matches a list of [Spec]s with [Matcher]s against a given input
## and returns a dictionary, used by [Nip.match_all].
module [Spec, Matcher, all_specs, anything, literal]

# Matcher and Spec below need a type variable
# because tag unions in type aliases are closed by default
# see https://roc.zulipchat.com/#narrow/channel/231634-beginners/topic/Type.20mismatch.20with.20a.20function.20in.20arguments/near/512117920

## Type alias for a matcher function.
##
## Unfortunately, the type variable `a` is needed here
## because tag unions in type aliases are closed by default.
## See [the Zulip thread](https://roc.zulipchat.com/#narrow/channel/231634-beginners/topic/Type.20mismatch.20with.20a.20function.20in.20arguments/near/512117920)
Matcher a : List U8 -> Result (List U8) [DoesNotMatch]a

## A spec defines a field name, length and a matcher function.
## [Template.parse_template] parses a template string into a list of specs.
##
## Here the type variable `a` is needed as well.
## To use `Spec` in the arguments definition use `(Spec _)`.
## See [the Zulip thread](https://roc.zulipchat.com/#narrow/channel/231634-beginners/topic/Type.20mismatch.20with.20a.20function.20in.20arguments/near/512117920)
Spec a : {
    field_name : [Anonymous, Named Str],
    length : U64,
    matcher : Matcher a,
}

## A matcher to match an orbitary character
anything : Matcher a
anything = |input|
    Ok(input)

## Returns a matcher that matches a given literal.
literal : List U8 -> Matcher a
literal = |value|
    \input ->
        if input == value then
            Ok(input)
        else
            Err(DoesNotMatch)

expect
    # that matcher generated by `literal`
    # returns `Ok` with the input
    # when the input matches the literal
    input = ['a', 'b']
    value = ['a', 'b']
    actual = literal(value)(input)
    actual == Ok(['a', 'b'])

expect
    # that matcher generated by `literal`
    # returns `Err(DoesNotMatch)`
    # when the input does not match the value
    input = ['n', 'o']
    value = ['a', 'b']
    actual = literal(value)(input)
    actual == Err(DoesNotMatch)

## Internal helper function,
## that returns a segment of a given length and the rest of the input
## or returns `Err(DoesNotMatch)` if the input is too short.
split_input_segment :
    List U8,
    { length : U64 }*
    -> Result { input_segment : List U8, rest_input : List U8 } [DoesNotMatch]
split_input_segment = |input, { length }|
    { before: input_segment, others: rest_input } = List.split_at(input, length)
    if List.len(input_segment) < length then
        Err(DoesNotMatch)
    else
        Ok({ input_segment, rest_input })

## See `all_specs` for the public API.
all_specs_recursive : List U8, List (Spec _), Dict Str Str -> Result (Dict Str Str) [DoesNotMatch]
all_specs_recursive = |input, specs, acc|
    when specs is
        [] ->
            if input == [] then
                Ok(acc)
            else
                Err(DoesNotMatch)

        [spec, .. as rest_specs] ->
            { input_segment, rest_input } = split_input_segment(input, spec)?

            # Even thought `field_value` is not always used,
            # it's important to call `spec.matcher?` here
            field_value =
                input_segment
                |> spec.matcher?
                |> Str.from_utf8_lossy

            all_specs_recursive(
                rest_input,
                rest_specs,
                when spec.field_name is
                    Named(name) -> Dict.insert(acc, name, field_value)
                    Anonymous -> acc,
            )

## Attempts to match a list of `Spec`s against the given input (as a list of bytes).
##
## Each `Spec` defines a field name, length and a matcher function.
## If all specs match successfully, returns a dictionary with named fields and their values,
## otherwise returns `Err(DoesNotMatch)`.
all_specs : List U8, List (Spec _) -> Result (Dict Str Str) [DoesNotMatch]
all_specs = |input, specs|
    all_specs_recursive(input, specs, Dict.empty({}))

expect
    # that `all_specs` passes segment of a request size
    # and returns `Ok` with the correct values
    # when input matches the specs
    input = ['B', 'u', 'z', 'z', 'F', 'u', 'z', 'z']
    specs = [
        {
            field_name: Named("field1"),
            length: 4,
            matcher: literal(['B', 'u', 'z', 'z']),
        },
        {
            field_name: Named("field2"),
            length: 4,
            matcher: literal(['F', 'u', 'z', 'z']),
        },
    ]
    actual = all_specs(input, specs)
    actual == Ok(Dict.from_list([("field1", "Buzz"), ("field2", "Fuzz")]))

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when at least one of the matchers returns `Err(DoesNotMatch)
    input = ['*', '*']
    specs = [
        {
            field_name: Named("field1"),
            length: 1,
            matcher: |x| Ok(x),
        },
        {
            field_name: Named("field2"),
            length: 1,
            matcher: |_| Err(DoesNotMatch),
        },
    ]
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when the specs list is empty but the input is not
    input = ['*']
    specs = []
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)

expect
    # that `all_specs` returns `Ok` with an empty dictionary
    # when the specs list and the input are empty
    input = []
    specs = []
    actual = all_specs(input, specs)
    actual == Ok(Dict.empty({}))

expect
    # that `all_specs` returns `Ok` with an empty dictionary
    # when the specs list and the input are empty
    input = []
    specs = []
    actual = all_specs(input, specs)
    actual == Ok(Dict.empty({}))

expect
    # that `all_specs` returns `Err(DoesNotMatch)`
    # when the input is too short, e.g. 5 < 2 + 5
    input = ['1', '2', '3', '4', '5']
    specs = [
        {
            field_name: Named("field1"),
            length: 2,
            matcher: |x| Ok(x),
        },
        {
            field_name: Named("field2"),
            length: 5,
            matcher: |x| Ok(x),
        },
    ]
    actual = all_specs(input, specs)
    actual == Err(DoesNotMatch)

expect
    # that `all_specs` returns `Ok` but without matching values
    # when the fields are anonymous
    input = ['*']
    specs = [
        {
            field_name: Anonymous,
            length: 1,
            matcher: |x| Ok(x),
        },
    ]
    actual = all_specs(input, specs)
    actual == Ok(Dict.empty({}))
